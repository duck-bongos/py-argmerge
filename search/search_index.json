{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>argmerge</code>","text":""},{"location":"#description","title":"Description","text":"<p>Customize how program defaults and overrides from config files, environment variables, and CLI arguments \"cross the threshold\" into your program.</p> <p></p> <p>We retrieve each possible source of program arguments as Python dictionaries and then perform dictionary updates between each source before passing the final dictionary to the wrapped function. Effectively:</p> <pre><code>source_1: dict\nsource_2: dict\n\nsource_1.update(source_2)\n\nfunction(**source_1)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>We recommend using <code>uv</code> for package management.</p> <pre><code>uv add argmerge\n</code></pre> <p>If you're using pip you can run</p> <pre><code>pip install argmerge\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#code-example","title":"Code Example","text":"<p>While designed for <code>main</code> functions, you can ddd the <code>@threshold</code> decorator to any program that interfaces with external variables or files.</p> <pre><code>from argmerge import threshold\n\n\n@threshold\ndef main(first: int, second: str, third: float = 0.0):\n    ...\n</code></pre>"},{"location":"#hierarchy","title":"Hierarchy","text":"<p>We determined the hierarchy based on (our perception of) developer experience. The intent is for higher priority sources to correspond to the quickest sources to change. For example, we perceive changing a CLI argument quicker than changing an environment variable - etc. </p> Level Rank Developer-provided 100 CLI 40 Environment Variable 30 YAML File 20 JSON File 10 Python Function Default 0"},{"location":"#faq","title":"FAQ","text":""},{"location":"#why-yaml-over-json","title":"Why YAML over JSON?","text":"<p>We prioritized YAML above JSON is because we find it significantly easier to read because it has less \"line noise\". JSON contains copious amounts of brackets (<code>{</code>,<code>}</code>) and commas. These are the only two sources that can pass dictionaries in by default. Of course, passing in different Regular expressions for environment variables and CLI arguments could also capture dictionaries, if you want to figure that out.</p>"},{"location":"#planned-future-work","title":"Planned Future Work","text":"<p>For specific bite-sized work, you can take a look at our project's GitHub issues. \u26a0\ufe0f Caution - this project is new and issues may be under-specified \u26a0\ufe0f</p>"},{"location":"#validation","title":"Validation","text":"<p>We want users to be able to validate the input arguments to their program using a <code>PyDantic BaseModel</code>. This would slot in after we collect the arguments from all the different sources.</p>"},{"location":"#customizing-threshold","title":"Customizing <code>@threshold</code>","text":"<p>We provide ways to customize reading environment variables and CLI arguments with the <code>env_prefix</code> and <code>cli_pattern</code> parameters. If developers want to go a step further and pull values from external sources we haven't considered (like <code>.cfg</code> files), we would like to allow them to do so.</p>"},{"location":"#databricks","title":"Databricks","text":"<p>Databricks offers a way to collect 'widgets' or 'secrets' in their notebooks at runtime and pass them into your program. This is cool. It also is higher-risk for not being able to exactly reproduce your workloads. This makes <code>@threshold</code> a very good candidate to merge arguments between the Databricks platform and other external sources. For example, though not recommended, it's possible to create widgets in a notebook that gets run in an asset bundle. Asset bundles can be run like CLI applications, which means you can pass arguments in from the CLI or the widgets.</p>"},{"location":"#authentication","title":"Authentication","text":"<p>This is a tricky one, and we may not do it. Since we truly want to provide everything a program needs to run, this would include any authentication keys - think Database access keys or application API keys. The way we'd retrieve keys varies between cloud platforms, as well as non-cloud platforms. What may make the most sense is for us to build some sort of plugin system that allows users to bring their own authentication </p>"},{"location":"examples/","title":"Example Usage","text":"<p>Below, we'll show you how to display the keywords from each source, how to bypass using the <code>threshold</code> decorator entirely, then walk through examples that build on each other to show how arguments are overwritten.</p>"},{"location":"examples/#tracing","title":"Tracing","text":"<p>We added the ability to trace the source of each keyword argument. We set this using <code>threshold</code>'s kwarg <code>trace_level</code>. <code>trace_level</code> uses the <code>loguru</code> package for logging and accepts the following arguments (case insenitive): </p> <ul> <li><code>\"critical\"</code></li> <li><code>\"warning\"</code></li> <li><code>\"success\"</code></li> <li><code>\"info\"</code></li> <li><code>\"debug\"</code></li> </ul> <p>We will see how this is used by trying out different log levels in the next set of examples.</p>"},{"location":"examples/#developer-provided-arguments-highest-level","title":"Developer-Provided Arguments (Highest Level)","text":"<p>If you need to debug something really quickly and don't want to fuss around with files or CLI, you can pass the values in as keywords. This bypasses any external values provided from files, environment variables, or the CLI.</p> <pre><code># main.py\nfrom argmerge import threshold\n\n\n@threshold(trace_level=\"DEBUG\")\ndef main(first, second, third: float = 3.0, fourth: float = 4.0, fifth: int = 5):\n    print(\n        f\"{first=}\",\n        f\"{second=}\",\n        f\"{third=}\",\n        f\"{fourth=}\",\n        f\"{fifth=}\",\n        sep=\"\\n\",\n    )\n\n\nif __name__ == \"__main__\":\n    main(first=1, second=\"second\")\n\n</code></pre> <p>Outputs a list of keyword arguments with their sources listed in ascending priority order</p> <pre><code>$ uv run main.py\n2025-10-15 21:08:02.681 | DEBUG    | argmerge.trace:_write_trace:51 - \nParameter Name  | Source                 \n=======================================\nthird   | Python Function Default\nfourth  | Python Function Default\nfifth   | Python Function Default\nfirst   | Developer-provided     \nsecond  | Developer-provided     \n=======================================\nfirst=1\nsecond='second'\nthird=3.0\nfourth=4.0\nfifth=5\n</code></pre>"},{"location":"examples/#default-function-values-lowest-level","title":"Default Function Values (Lowest Level)","text":"<pre><code># main.py\nfrom argmerge import threshold\n\n\n@threshold(trace_level=\"DEBUG\")\ndef main(\n    first: int = 1,\n    second: str = \"second\",\n    third: float = 3.0,\n    fourth: float = 4.0,\n    fifth: int = 5,\n):\n    print(\n        f\"{first=}\",\n        f\"{second=}\",\n        f\"{third=}\",\n        f\"{fourth=}\",\n        f\"{fifth=}\",\n        sep=\"\\n\",\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Output</p> <pre><code>$ uv run main.py\n2025-10-15 21:19:07.874 | DEBUG    | argmerge.trace:_write_trace:51 - \nParameter Name  | Source                 \n=======================================\nfirst   | Python Function Default\nsecond  | Python Function Default\nthird   | Python Function Default\nfourth  | Python Function Default\nfifth   | Python Function Default\n=======================================\nfirst=1\nsecond='second'\nthird=3.0\nfourth=4.0\nfifth=5\n</code></pre>"},{"location":"examples/#json-second-lowest","title":"JSON (Second Lowest)","text":"<p>JSON Config</p> <pre><code>// threshold.json\n{\n    \"first\": 100,\n    \"second\": \"Python\"\n}\n</code></pre> <pre><code># main.py\nfrom argmerge import threshold\n\n\n@threshold(fpath_json=\"threshold.json\", trace_level=\"DEBUG\")\ndef main(\n    first: int,\n    second: str,\n    third: float = 3.0,\n    fourth: float = 4.0,\n    fifth: int = 5,\n):\n    print(\n        f\"{first=}\",\n        f\"{second=}\",\n        f\"{third=}\",\n        f\"{fourth=}\",\n        f\"{fifth=}\",\n        sep=\"\\n\",\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Outputs</p> <pre><code>$ uv run main.py\n2025-10-15 21:19:36.388 | DEBUG    | argmerge.trace:_write_trace:51 - \nParameter Name  | Source                 \n=======================================\nthird   | Python Function Default\nfourth  | Python Function Default\nfifth   | Python Function Default\nfirst   | JSON (threshold.json)  \nsecond  | JSON (threshold.json)  \n=======================================\nfirst=100\nsecond='Python'\nthird=3.0\nfourth=4.0\nfifth=5 \n</code></pre>"},{"location":"examples/#yaml-third-lowest","title":"YAML (Third Lowest)","text":"<pre><code># threshold.yaml\nthird: -3.333\n</code></pre> <pre><code># main.py\nfrom argmerge import threshold\n\n\n@threshold(\n    fpath_json=\"threshold.json\", \n    fpath_yaml=\"threshold.yaml\", \n    trace_level=\"DEBUG\"\n)\ndef main(\n    first: int,\n    second: str,\n    third: float = 3.0,\n    fourth: float = 4.0,\n    fifth: int = 5,\n):\n    print(\n        f\"{first=}\",\n        f\"{second=}\",\n        f\"{third=}\",\n        f\"{fourth=}\",\n        f\"{fifth=}\",\n        sep=\"\\n\",\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Output</p> <pre><code>$ uv run main.py\n2025-10-15 21:24:21.619 | DEBUG    | argmerge.trace:_write_trace:51 - \nParameter Name  | Source                 \n=======================================\nfourth  | Python Function Default\nfifth   | Python Function Default\nfirst   | JSON (threshold.json)  \nsecond  | JSON (threshold.json)  \nthird   | YAML (threshold.yaml)  \n=======================================\nfirst=100\nsecond='Python'\nthird=-3.333\nfourth=4.0\nfifth=5\n</code></pre>"},{"location":"examples/#environment-variables-third-highest","title":"Environment Variables (Third Highest)","text":"<pre><code>$ export EXAMPLE_THRESH_FOURTH=-14.0\n</code></pre> <pre><code># main.py\nfrom argmerge import threshold\n\n\n@threshold(\n    fpath_json=\"threshold.json\",\n    fpath_yaml=\"threshold.yaml\",\n    env_prefix=\"EXAMPLE_THRESH\",\n    trace_level=\"WARNING\",\n)\ndef main(\n    first: int,\n    second: str,\n    third: float = 3.0,\n    fourth: float = 4.0,\n    fifth: int = 5,\n):\n    print(\n        f\"{first=}\",\n        f\"{second=}\",\n        f\"{third=}\",\n        f\"{fourth=}\",\n        f\"{fifth=}\",\n        sep=\"\\n\",\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Outputs</p> <pre><code>$ uv run main.py\n2025-10-15 21:26:37.188 | DEBUG    | argmerge.trace:_write_trace:51 - \nParameter Name  | Source                 \n=======================================\nfifth   | Python Function Default\nfirst   | JSON (threshold.json)  \nsecond  | JSON (threshold.json)  \nthird   | YAML (threshold.yaml)  \nfourth  | Environment Variable   \n=======================================\nfirst=100\nsecond='Python'\nthird=-3.333\nfourth=-14.0\nfifth=5 \n</code></pre>"},{"location":"examples/#command-line-arguments-second-highest","title":"Command-Line Arguments (Second Highest)","text":"<pre><code># main.py\nfrom argmerge import threshold\n\n\n@threshold(\n    fpath_json=\"threshold.json\",\n    fpath_yaml=\"threshold.yaml\",\n    env_prefix=\"EXAMPLE_THRESH\",\n    cli_pattern=r\"--([A-Za-z_-]+)=([0-9A-Za-z._-]+)\",  # the default pattern\n    trace_level=\"WARNING\",\n)\ndef main(\n    first: int,\n    second: str,\n    third: float = 3.0,\n    fourth: float = 4.0,\n    fifth: int = 5,\n):\n    print(\n        f\"{first=}\",\n        f\"{second=}\",\n        f\"{third=}\",\n        f\"{fourth=}\",\n        f\"{fifth=}\",\n        sep=\"\\n\",\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Output</p> <pre><code>$ uv run main.py -- --fifth=3.14\n$ # you can also run\n$ # python main.py --fifth=3.14\n2025-10-15 21:28:51.405 | DEBUG    | argmerge.trace:_write_trace:51 - \nParameter Name  | Source               \n=====================================\nfirst   | JSON (threshold.json)\nsecond  | JSON (threshold.json)\nthird   | YAML (threshold.yaml)\nfourth  | Environment Variable \nfifth   | CLI                  \n=====================================\nfirst=100\nsecond='Python'\nthird=-3.333\nfourth=-14.0\nfifth='3.14'   \n</code></pre>"},{"location":"autoapi/summary/","title":"Summary","text":"<ul> <li>argmerge<ul> <li>base</li> <li>cli</li> <li>decorator</li> <li>env</li> <li>func</li> <li>json</li> <li>trace</li> <li>utils</li> <li>yaml</li> </ul> </li> </ul>"},{"location":"autoapi/argmerge/","title":"argmerge","text":""},{"location":"autoapi/argmerge/#argmerge.threshold","title":"threshold","text":"<pre><code>threshold(*args, fpath_json='', fpath_yaml='', env_prefix=ENV_PREFIX, cli_pattern=CLI_PATTERN, trace_level='', debug=False, **kwargs)\n</code></pre> <p>Merge arguments from external environment sources into the program.</p> <p>We allow syntax of both @threshold and @threshold(), depending whether you want to allow for defaults or override them.</p> <p>Parameters:</p> <ul> <li> <code>fpath_json</code>               (<code>str | Path</code>, default:                   <code>''</code> )           \u2013            <p>The path to find a JSON configuration file. Defaults to \"\".</p> </li> <li> <code>fpath_yaml</code>               (<code>str | Path</code>, default:                   <code>''</code> )           \u2013            <p>The path to find a YAML configuration file. Defaults to \"\".</p> </li> <li> <code>env_prefix</code>               (<code>str | Pattern[str]</code>, default:                   <code>ENV_PREFIX</code> )           \u2013            <p>The string or Regex to match environment variables against. Defaults to ENV_PREFIX, which is 'THRESH'.</p> </li> <li> <code>cli_pattern</code>               (<code>str | Pattern[str]</code>, default:                   <code>CLI_PATTERN</code> )           \u2013            <p>The string or Regex to match CLI arguments against. Defaults to CLI_PATTERN.</p> </li> <li> <code>trace_level</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Trace the source of each kwarg and display at the specified trace log level. Defaults to \"\", which skips the trace entirely.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Turns on debugging for all the parsers. Defaults to False.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p><code>level</code> must be in one of the default loguru logger levels: <code>(\"critical\", \"warning\", \"success\", \"info\", \"debug\")</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>callable</code>          \u2013            <p>A wrapped, yet-to-be-called function with resolved arguments.</p> </li> </ul> Source code in <code>src/argmerge/decorator.py</code> <pre><code>def threshold(\n    *args,\n    fpath_json: str | Path = \"\",\n    fpath_yaml: str | Path = \"\",\n    env_prefix: str | re.Pattern[str] = ENV_PREFIX,  # 'THRESH', also set at PYTHRESH\n    cli_pattern: str | re.Pattern[str] = CLI_PATTERN,\n    trace_level: str = \"\",\n    debug: bool = False,\n    **kwargs,\n):\n    \"\"\"Merge arguments from external environment sources into the program.\n\n    We allow syntax of both @threshold and @threshold(), depending whether you want to\n    allow for defaults or override them.\n\n    Args:\n        fpath_json (str | Path, optional): The path to find a JSON configuration file.\n            Defaults to \"\".\n        fpath_yaml (str | Path, optional): The path to find a YAML configuration file.\n            Defaults to \"\".\n        env_prefix (str | re.Pattern[str], optional): The string or Regex to match\n            environment variables against. Defaults to ENV_PREFIX, which is 'THRESH'.\n        cli_pattern (str | re.Pattern[str], optional): The string or Regex to match\n            CLI arguments against. Defaults to CLI_PATTERN.\n        trace_level (str, optional): Trace the source of each kwarg and display at the\n            specified trace log level. Defaults to \"\", which skips the trace entirely.\n        debug (bool, optional): Turns on debugging for all the parsers.\n            Defaults to False.\n\n    Raises:\n        ValueError: `level` must be in one of the default loguru logger levels:\n            `(\"critical\", \"warning\", \"success\", \"info\", \"debug\")`\n\n    Returns:\n        callable: A wrapped, yet-to-be-called function with resolved arguments.\n    \"\"\"\n    if len(args) == 1:\n        # allow syntax of @threshold and @threshold()\n        return threshold()(args[0])\n\n    else:\n\n        def wrapped(f):\n            @functools.wraps(f)\n            def wrapped_f(*_args, **_kwargs):\n                _threshold_kwargs, _change_ledger = dict(), dict()\n                _threshold_kwargs, _change_ledger = parse_func(\n                    _threshold_kwargs, _change_ledger, f, debug=debug\n                )\n\n                _threshold_kwargs, _change_ledger = parse_json(\n                    _threshold_kwargs,\n                    _change_ledger,\n                    fpath_json=fpath_json,\n                    debug=debug,\n                )\n\n                _threshold_kwargs, _change_ledger = parse_yaml(\n                    _threshold_kwargs,\n                    _change_ledger,\n                    fpath_yaml=fpath_yaml,\n                    debug=debug,\n                )\n\n                _threshold_kwargs, _change_ledger = parse_env(\n                    _threshold_kwargs,\n                    _change_ledger,\n                    env_prefix=env_prefix,\n                    debug=debug,\n                )\n\n                _threshold_kwargs, _change_ledger = parse_cli(\n                    _threshold_kwargs,\n                    _change_ledger,\n                    cli_pattern=cli_pattern,\n                    debug=debug,\n                )\n\n                _threshold_kwargs, _change_ledger = parse_func_runtime(\n                    _threshold_kwargs, _change_ledger, func_kwargs=_kwargs, debug=debug\n                )\n\n                if trace_level.lower() in LOG_LEVELS:\n                    trace_arg_lineage(\n                        f,\n                        _change_ledger,\n                        level=trace_level,\n                    )\n\n                elif trace_level == \"\":\n                    # default behavior\n                    pass\n\n                else:\n                    raise ValueError(\n                        f\"'trace_level' has been set to '{trace_level}', which is not \"\n                        \"supported. Please set 'trace_level' to an empty string or one\"\n                        f\" of: {LOG_LEVELS}.\"\n                    )\n\n                return f(*_args, **_threshold_kwargs)\n\n            return wrapped_f\n\n        return wrapped\n</code></pre>"},{"location":"autoapi/argmerge/base/","title":"base","text":"<p>Module that holds the Abstract Base Class for all external parsers.</p>"},{"location":"autoapi/argmerge/base/#argmerge.base.SourceParser","title":"SourceParser","text":"<p>               Bases: <code>ABC</code></p> <p>The base parser from which all other parsers are built.</p> <p>To build a new parser, you will need to subclass this one. Set 'rank' and 'label' as class variables and overwrite <code>__call__</code> with your parser. You MUST include three parameters: <code>threshold_kwargs</code>, <code>ledger</code>, and <code>debug</code>. This will allow you to add your own with other keyword arguments. You can look at any of the existing subclasses for how this works. After you build your subclass, you will instantiate it, setting it equal to a variable, ideally beginning with <code>'parse_'</code>. This will allow you to treat it like a function by invoking the <code>__call__</code> method, which calls your parser.</p> <p>Parameters:</p> <ul> <li> <code>rank</code>               (<code>int</code>)           \u2013            <p>The priority of the parser. Generally, we aim between [0,100] for human-readabilty.</p> </li> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The debugging label to indicate an argument was set at the .</p> </li> </ul> Source code in <code>src/argmerge/base.py</code> <pre><code>class SourceParser(ABC):\n    \"\"\"The base parser from which all other parsers are built.\n\n    To build a new parser, you will need to subclass this one. Set 'rank' and 'label'\n    as class variables and overwrite `__call__` with your parser. You MUST include\n    three parameters: `threshold_kwargs`, `ledger`, and `debug`. This will allow you\n    to add your own with other keyword arguments. You can look at any of the existing\n    subclasses for how this works. After you build your subclass, you will instantiate\n    it, setting it equal to a variable, ideally beginning with `'parse_'`. This will\n    allow you to treat it like a function by invoking the `__call__` method, which calls\n    your parser.\n\n    Args:\n        rank (int): The priority of the parser. Generally, we aim between [0,100] for\n            human-readabilty.\n        label (str): The debugging label to indicate an argument was set at the\n            &lt;source level&gt;.\n    \"\"\"\n\n    rank: int = -100\n    label: str = \"\"\n\n    def __init__(cls):\n        cls.label\n        cls.rank\n\n    @abstractmethod\n    def __call__(\n        cls, threshold_kwargs: dict, ledger: dict, debug: bool = False, **kwargs\n    ) -&gt; tuple[dict, dict]:\n        \"\"\"This is too abstract to be covered\"\"\"\n</code></pre>"},{"location":"autoapi/argmerge/base/#argmerge.base.SourceParser.__call__","title":"__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(threshold_kwargs, ledger, debug=False, **kwargs)\n</code></pre> <p>This is too abstract to be covered</p> Source code in <code>src/argmerge/base.py</code> <pre><code>@abstractmethod\ndef __call__(\n    cls, threshold_kwargs: dict, ledger: dict, debug: bool = False, **kwargs\n) -&gt; tuple[dict, dict]:\n    \"\"\"This is too abstract to be covered\"\"\"\n</code></pre>"},{"location":"autoapi/argmerge/cli/","title":"cli","text":"<p>Module that provides a flexible CLI parser component in the decorator.</p> <pre><code>CLI_PATTERN: re.Pattern = re.compile(r\"--([A-Za-z_-]+)=([0-9A-Za-z._-]+)\")\n</code></pre> <ul> <li>matches <code>'--arg=value'</code></li> <li>does not match <code>'--arg value'</code></li> </ul>"},{"location":"autoapi/argmerge/cli/#argmerge.cli.CLIParser","title":"CLIParser","text":"<p>               Bases: <code>SourceParser</code></p> <p>The parser the extracts relevant CLI arguments.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The debugging label to indicate an argument was set at the CLI.</p> </li> <li> <code>rank</code>               (<code>int</code>)           \u2013            <p>The priority of the parser. Generally, we aim between [0,100] for human-readabilty.</p> </li> </ul> Source code in <code>src/argmerge/cli.py</code> <pre><code>class CLIParser(SourceParser):\n    \"\"\"The parser the extracts relevant CLI arguments.\n\n    params:\n        label (str): The debugging label to indicate an argument was set at the CLI.\n        rank (int): The priority of the parser. Generally, we aim between [0,100] for\n            human-readabilty.\n\n    \"\"\"\n\n    label: str = \"CLI\"\n    rank: int = 40\n\n    def __call__(\n        cls,\n        threshold_kwargs: dict[str, Any],\n        change_ledger: dict[str, dict[str, str | int]],\n        cli_pattern: re.Pattern[str] = CLI_PATTERN,\n        debug: bool = False,\n        **kwargs,\n    ) -&gt; tuple[dict, dict]:\n        \"\"\"Parse the CLI commands using the cli_pattern regular expression.\n\n        Args:\n            threshold_kwargs (dict[str, Any]): kwargs passed around the\n                @threshold decorator.\n            change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are\n                updated inside the @threshold decorator.\n            cli_pattern (re.Pattern[str], optional): The regular expression pattern\n                used to extract arguments from the CLI. Defaults to CLI_PATTERN.\n            debug (bool, optional): Flag to turn on more logging. Defaults to False.\n\n        Returns:\n            tuple[dict, dict]: an updated `threshold_kwargs` and `change_ledger`.\n        \"\"\"\n        _cli_kwargs: dict\n        _cli_input: str\n\n        if debug:\n            LOGGER.remove()\n            LOGGER.add(sys.stderr, level=\"DEBUG\")\n\n        if isinstance(cli_pattern, re.Pattern):\n            _cli_pattern = cli_pattern\n\n        else:\n            _cli_pattern = re.compile(rf\"{cli_pattern}\")\n\n        LOGGER.debug(f\"{cli_pattern=}\")\n        LOGGER.debug(f\"{_cli_pattern=}\")\n        LOGGER.debug(f\"{sys.argv=}\")\n        _cli_input = \" \".join(sys.argv[1:])\n        LOGGER.debug(f\"{_cli_input}\")\n\n        _cli_kwargs = dict(_cli_pattern.findall(_cli_input))\n        LOGGER.debug(f\"{_cli_kwargs=}\")\n\n        threshold_kwargs.update(_cli_kwargs)\n        LOGGER.debug(f\"Updated {threshold_kwargs=}\")\n\n        for key in _cli_kwargs:\n            change_ledger[key] = {\"label\": cls.label, \"rank\": cls.rank}\n\n        return threshold_kwargs, change_ledger\n</code></pre>"},{"location":"autoapi/argmerge/cli/#argmerge.cli.CLIParser.__call__","title":"__call__","text":"<pre><code>__call__(threshold_kwargs, change_ledger, cli_pattern=CLI_PATTERN, debug=False, **kwargs)\n</code></pre> <p>Parse the CLI commands using the cli_pattern regular expression.</p> <p>Parameters:</p> <ul> <li> <code>threshold_kwargs</code>               (<code>dict[str, Any]</code>)           \u2013            <p>kwargs passed around the @threshold decorator.</p> </li> <li> <code>change_ledger</code>               (<code>dict[str, dict[str, str | int]]</code>)           \u2013            <p>Tracks when kwargs are updated inside the @threshold decorator.</p> </li> <li> <code>cli_pattern</code>               (<code>Pattern[str]</code>, default:                   <code>CLI_PATTERN</code> )           \u2013            <p>The regular expression pattern used to extract arguments from the CLI. Defaults to CLI_PATTERN.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to turn on more logging. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[dict, dict]</code>           \u2013            <p>tuple[dict, dict]: an updated <code>threshold_kwargs</code> and <code>change_ledger</code>.</p> </li> </ul> Source code in <code>src/argmerge/cli.py</code> <pre><code>def __call__(\n    cls,\n    threshold_kwargs: dict[str, Any],\n    change_ledger: dict[str, dict[str, str | int]],\n    cli_pattern: re.Pattern[str] = CLI_PATTERN,\n    debug: bool = False,\n    **kwargs,\n) -&gt; tuple[dict, dict]:\n    \"\"\"Parse the CLI commands using the cli_pattern regular expression.\n\n    Args:\n        threshold_kwargs (dict[str, Any]): kwargs passed around the\n            @threshold decorator.\n        change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are\n            updated inside the @threshold decorator.\n        cli_pattern (re.Pattern[str], optional): The regular expression pattern\n            used to extract arguments from the CLI. Defaults to CLI_PATTERN.\n        debug (bool, optional): Flag to turn on more logging. Defaults to False.\n\n    Returns:\n        tuple[dict, dict]: an updated `threshold_kwargs` and `change_ledger`.\n    \"\"\"\n    _cli_kwargs: dict\n    _cli_input: str\n\n    if debug:\n        LOGGER.remove()\n        LOGGER.add(sys.stderr, level=\"DEBUG\")\n\n    if isinstance(cli_pattern, re.Pattern):\n        _cli_pattern = cli_pattern\n\n    else:\n        _cli_pattern = re.compile(rf\"{cli_pattern}\")\n\n    LOGGER.debug(f\"{cli_pattern=}\")\n    LOGGER.debug(f\"{_cli_pattern=}\")\n    LOGGER.debug(f\"{sys.argv=}\")\n    _cli_input = \" \".join(sys.argv[1:])\n    LOGGER.debug(f\"{_cli_input}\")\n\n    _cli_kwargs = dict(_cli_pattern.findall(_cli_input))\n    LOGGER.debug(f\"{_cli_kwargs=}\")\n\n    threshold_kwargs.update(_cli_kwargs)\n    LOGGER.debug(f\"Updated {threshold_kwargs=}\")\n\n    for key in _cli_kwargs:\n        change_ledger[key] = {\"label\": cls.label, \"rank\": cls.rank}\n\n    return threshold_kwargs, change_ledger\n</code></pre>"},{"location":"autoapi/argmerge/decorator/","title":"decorator","text":"<p>Module that contains the main decorator, <code>@threshold</code>.</p> Usage <pre><code># main.py\nfrom argmerge import threshold\n\n@threshold\ndef main(first: int, second: str, third: float = 3.0):\n    ...\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>Many more examples of how to use this can be found in the Examples section</p>"},{"location":"autoapi/argmerge/decorator/#argmerge.decorator.threshold","title":"threshold","text":"<pre><code>threshold(*args, fpath_json='', fpath_yaml='', env_prefix=ENV_PREFIX, cli_pattern=CLI_PATTERN, trace_level='', debug=False, **kwargs)\n</code></pre> <p>Merge arguments from external environment sources into the program.</p> <p>We allow syntax of both @threshold and @threshold(), depending whether you want to allow for defaults or override them.</p> <p>Parameters:</p> <ul> <li> <code>fpath_json</code>               (<code>str | Path</code>, default:                   <code>''</code> )           \u2013            <p>The path to find a JSON configuration file. Defaults to \"\".</p> </li> <li> <code>fpath_yaml</code>               (<code>str | Path</code>, default:                   <code>''</code> )           \u2013            <p>The path to find a YAML configuration file. Defaults to \"\".</p> </li> <li> <code>env_prefix</code>               (<code>str | Pattern[str]</code>, default:                   <code>ENV_PREFIX</code> )           \u2013            <p>The string or Regex to match environment variables against. Defaults to ENV_PREFIX, which is 'THRESH'.</p> </li> <li> <code>cli_pattern</code>               (<code>str | Pattern[str]</code>, default:                   <code>CLI_PATTERN</code> )           \u2013            <p>The string or Regex to match CLI arguments against. Defaults to CLI_PATTERN.</p> </li> <li> <code>trace_level</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Trace the source of each kwarg and display at the specified trace log level. Defaults to \"\", which skips the trace entirely.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Turns on debugging for all the parsers. Defaults to False.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p><code>level</code> must be in one of the default loguru logger levels: <code>(\"critical\", \"warning\", \"success\", \"info\", \"debug\")</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>callable</code>          \u2013            <p>A wrapped, yet-to-be-called function with resolved arguments.</p> </li> </ul> Source code in <code>src/argmerge/decorator.py</code> <pre><code>def threshold(\n    *args,\n    fpath_json: str | Path = \"\",\n    fpath_yaml: str | Path = \"\",\n    env_prefix: str | re.Pattern[str] = ENV_PREFIX,  # 'THRESH', also set at PYTHRESH\n    cli_pattern: str | re.Pattern[str] = CLI_PATTERN,\n    trace_level: str = \"\",\n    debug: bool = False,\n    **kwargs,\n):\n    \"\"\"Merge arguments from external environment sources into the program.\n\n    We allow syntax of both @threshold and @threshold(), depending whether you want to\n    allow for defaults or override them.\n\n    Args:\n        fpath_json (str | Path, optional): The path to find a JSON configuration file.\n            Defaults to \"\".\n        fpath_yaml (str | Path, optional): The path to find a YAML configuration file.\n            Defaults to \"\".\n        env_prefix (str | re.Pattern[str], optional): The string or Regex to match\n            environment variables against. Defaults to ENV_PREFIX, which is 'THRESH'.\n        cli_pattern (str | re.Pattern[str], optional): The string or Regex to match\n            CLI arguments against. Defaults to CLI_PATTERN.\n        trace_level (str, optional): Trace the source of each kwarg and display at the\n            specified trace log level. Defaults to \"\", which skips the trace entirely.\n        debug (bool, optional): Turns on debugging for all the parsers.\n            Defaults to False.\n\n    Raises:\n        ValueError: `level` must be in one of the default loguru logger levels:\n            `(\"critical\", \"warning\", \"success\", \"info\", \"debug\")`\n\n    Returns:\n        callable: A wrapped, yet-to-be-called function with resolved arguments.\n    \"\"\"\n    if len(args) == 1:\n        # allow syntax of @threshold and @threshold()\n        return threshold()(args[0])\n\n    else:\n\n        def wrapped(f):\n            @functools.wraps(f)\n            def wrapped_f(*_args, **_kwargs):\n                _threshold_kwargs, _change_ledger = dict(), dict()\n                _threshold_kwargs, _change_ledger = parse_func(\n                    _threshold_kwargs, _change_ledger, f, debug=debug\n                )\n\n                _threshold_kwargs, _change_ledger = parse_json(\n                    _threshold_kwargs,\n                    _change_ledger,\n                    fpath_json=fpath_json,\n                    debug=debug,\n                )\n\n                _threshold_kwargs, _change_ledger = parse_yaml(\n                    _threshold_kwargs,\n                    _change_ledger,\n                    fpath_yaml=fpath_yaml,\n                    debug=debug,\n                )\n\n                _threshold_kwargs, _change_ledger = parse_env(\n                    _threshold_kwargs,\n                    _change_ledger,\n                    env_prefix=env_prefix,\n                    debug=debug,\n                )\n\n                _threshold_kwargs, _change_ledger = parse_cli(\n                    _threshold_kwargs,\n                    _change_ledger,\n                    cli_pattern=cli_pattern,\n                    debug=debug,\n                )\n\n                _threshold_kwargs, _change_ledger = parse_func_runtime(\n                    _threshold_kwargs, _change_ledger, func_kwargs=_kwargs, debug=debug\n                )\n\n                if trace_level.lower() in LOG_LEVELS:\n                    trace_arg_lineage(\n                        f,\n                        _change_ledger,\n                        level=trace_level,\n                    )\n\n                elif trace_level == \"\":\n                    # default behavior\n                    pass\n\n                else:\n                    raise ValueError(\n                        f\"'trace_level' has been set to '{trace_level}', which is not \"\n                        \"supported. Please set 'trace_level' to an empty string or one\"\n                        f\" of: {LOG_LEVELS}.\"\n                    )\n\n                return f(*_args, **_threshold_kwargs)\n\n            return wrapped_f\n\n        return wrapped\n</code></pre>"},{"location":"autoapi/argmerge/env/","title":"env","text":""},{"location":"autoapi/argmerge/env/#argmerge.env.EnvParser","title":"EnvParser","text":"<p>               Bases: <code>SourceParser</code></p> <p>The parser the extracts relevant environment variables.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The debugging label to indicate an argument was set by environment variables.</p> </li> <li> <code>rank</code>               (<code>int</code>)           \u2013            <p>The priority of the parser. Generally, we aim between [0,100] for human-readabilty.</p> </li> </ul> Source code in <code>src/argmerge/env.py</code> <pre><code>class EnvParser(SourceParser):\n    \"\"\"The parser the extracts relevant environment variables.\n\n    Args:\n        label (str): The debugging label to indicate an argument was set by environment\n            variables.\n        rank (int): The priority of the parser. Generally, we aim between [0,100] for\n            human-readabilty.\n    \"\"\"\n\n    rank: int = 30\n    label: str = \"Environment Variable\"\n\n    def __call__(\n        cls,\n        threshold_kwargs: dict[str, Any],\n        change_ledger: dict[str, dict[str, str | int]],\n        env_prefix: str | re.Pattern[str] = ENV_PREFIX,\n        debug=False,\n        **kwargs,\n    ):\n        \"\"\"Parse the environment variables using the `env_prefix` and update inputs.\n\n        Args:\n            threshold_kwargs (dict[str, Any]): kwargs passed around the\n                @threshold decorator.\n            change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are\n                updated inside the @threshold decorator.\n            env_prefix (str | re.Pattern[str], optional): The prefix used to search for\n                set environment variables. Defaults to ENV_PREFIX, which is 'THRESH_'.\n            debug (bool, optional): Flag to turn on more logging. Defaults to False.\n\n        Raises:\n            ValueError: `env_prefix` must either be a string or Regex string pattern.\n\n        Returns:\n            tuple[dict, dict]: an updated `threshold_kwargs` and `change_ledger`.\n        \"\"\"\n        if debug:\n            LOGGER.remove()\n            LOGGER.add(sys.stderr, level=\"DEBUG\")\n\n        if isinstance(env_prefix, re.Pattern):\n            pattern = env_prefix\n\n        elif isinstance(env_prefix, str):\n            pattern = re.compile(rf\"(?:{env_prefix.upper()}.)([A-Za-z0\\-\\_]+)\")\n\n        else:\n            raise ValueError(\n                f\"'env_prefix' must be either a string or Regex string pattern. Received: {env_prefix} ({type(env_prefix)}).\"\n            )\n\n        LOGGER.debug(f\"{env_prefix=}\")\n        LOGGER.debug(f\"{pattern=}\")\n\n        _env_kwargs = {}\n\n        for k, v in os.environ.items():\n            _search = pattern.search(k)\n\n            if _search is not None:\n                try:\n                    key = _search.group(1).lower()\n                    LOGGER.debug(f\"{key=} {v=}\")\n                    _env_kwargs[key] = extract_literals(v)\n\n                except IndexError:\n                    LOGGER.debug(f\"Regex search failed on environment variable {k}.\")\n\n            else:\n                LOGGER.debug(f\"Miss: {k=}\")\n\n        LOGGER.debug(f\"{_env_kwargs=}\")\n        threshold_kwargs.update(_env_kwargs)\n\n        LOGGER.debug(f\"Updated {threshold_kwargs=}\")\n\n        for key in _env_kwargs:\n            change_ledger[key] = {\"label\": cls.label, \"rank\": cls.rank}\n\n        return threshold_kwargs, change_ledger\n</code></pre>"},{"location":"autoapi/argmerge/env/#argmerge.env.EnvParser.__call__","title":"__call__","text":"<pre><code>__call__(threshold_kwargs, change_ledger, env_prefix=ENV_PREFIX, debug=False, **kwargs)\n</code></pre> <p>Parse the environment variables using the <code>env_prefix</code> and update inputs.</p> <p>Parameters:</p> <ul> <li> <code>threshold_kwargs</code>               (<code>dict[str, Any]</code>)           \u2013            <p>kwargs passed around the @threshold decorator.</p> </li> <li> <code>change_ledger</code>               (<code>dict[str, dict[str, str | int]]</code>)           \u2013            <p>Tracks when kwargs are updated inside the @threshold decorator.</p> </li> <li> <code>env_prefix</code>               (<code>str | Pattern[str]</code>, default:                   <code>ENV_PREFIX</code> )           \u2013            <p>The prefix used to search for set environment variables. Defaults to ENV_PREFIX, which is 'THRESH_'.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to turn on more logging. Defaults to False.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p><code>env_prefix</code> must either be a string or Regex string pattern.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>tuple[dict, dict]: an updated <code>threshold_kwargs</code> and <code>change_ledger</code>.</p> </li> </ul> Source code in <code>src/argmerge/env.py</code> <pre><code>def __call__(\n    cls,\n    threshold_kwargs: dict[str, Any],\n    change_ledger: dict[str, dict[str, str | int]],\n    env_prefix: str | re.Pattern[str] = ENV_PREFIX,\n    debug=False,\n    **kwargs,\n):\n    \"\"\"Parse the environment variables using the `env_prefix` and update inputs.\n\n    Args:\n        threshold_kwargs (dict[str, Any]): kwargs passed around the\n            @threshold decorator.\n        change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are\n            updated inside the @threshold decorator.\n        env_prefix (str | re.Pattern[str], optional): The prefix used to search for\n            set environment variables. Defaults to ENV_PREFIX, which is 'THRESH_'.\n        debug (bool, optional): Flag to turn on more logging. Defaults to False.\n\n    Raises:\n        ValueError: `env_prefix` must either be a string or Regex string pattern.\n\n    Returns:\n        tuple[dict, dict]: an updated `threshold_kwargs` and `change_ledger`.\n    \"\"\"\n    if debug:\n        LOGGER.remove()\n        LOGGER.add(sys.stderr, level=\"DEBUG\")\n\n    if isinstance(env_prefix, re.Pattern):\n        pattern = env_prefix\n\n    elif isinstance(env_prefix, str):\n        pattern = re.compile(rf\"(?:{env_prefix.upper()}.)([A-Za-z0\\-\\_]+)\")\n\n    else:\n        raise ValueError(\n            f\"'env_prefix' must be either a string or Regex string pattern. Received: {env_prefix} ({type(env_prefix)}).\"\n        )\n\n    LOGGER.debug(f\"{env_prefix=}\")\n    LOGGER.debug(f\"{pattern=}\")\n\n    _env_kwargs = {}\n\n    for k, v in os.environ.items():\n        _search = pattern.search(k)\n\n        if _search is not None:\n            try:\n                key = _search.group(1).lower()\n                LOGGER.debug(f\"{key=} {v=}\")\n                _env_kwargs[key] = extract_literals(v)\n\n            except IndexError:\n                LOGGER.debug(f\"Regex search failed on environment variable {k}.\")\n\n        else:\n            LOGGER.debug(f\"Miss: {k=}\")\n\n    LOGGER.debug(f\"{_env_kwargs=}\")\n    threshold_kwargs.update(_env_kwargs)\n\n    LOGGER.debug(f\"Updated {threshold_kwargs=}\")\n\n    for key in _env_kwargs:\n        change_ledger[key] = {\"label\": cls.label, \"rank\": cls.rank}\n\n    return threshold_kwargs, change_ledger\n</code></pre>"},{"location":"autoapi/argmerge/func/","title":"func","text":"<p>Module to work with retrieving arguments functions</p>"},{"location":"autoapi/argmerge/func/#argmerge.func.FuncDefaultParser","title":"FuncDefaultParser","text":"<p>               Bases: <code>SourceParser</code></p> <p>Builds the parser to extract default arguments from a function signature</p> <p>This is the lowest-ranked parser.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The debugging label to indicate an argument was set at the CLI.</p> </li> <li> <code>rank</code>               (<code>int</code>)           \u2013            <p>The priority of the parser. Generally, we aim between [0,100] for human-readabilty.</p> </li> </ul> Source code in <code>src/argmerge/func.py</code> <pre><code>class FuncDefaultParser(SourceParser):\n    \"\"\"Builds the parser to extract default arguments from a function signature\n\n    This is the lowest-ranked parser.\n\n    params:\n        label (str): The debugging label to indicate an argument was set at the CLI.\n        rank (int): The priority of the parser. Generally, we aim between [0,100] for\n            human-readabilty.\n\n    \"\"\"\n\n    label: str = \"Python Function Default\"\n    rank: int = 0\n\n    def __call__(\n        cls,\n        threshold_kwargs: dict,\n        change_ledger: dict,\n        f: Callable,\n        debug: bool = False,\n    ) -&gt; tuple[dict, dict]:\n        \"\"\"Lowest level parser - retrieve function defaults as fallback arguments.\n\n        Args:\n            threshold_kwargs (dict[str, Any]): kwargs passed around the\n                @threshold decorator.\n            change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are\n                updated inside the @threshold decorator.\n            f (Callable): The function we wrap.\n            debug (bool, optional): Flag to turn on more logging. Defaults to False.\n\n\n        Returns:\n            tuple[dict, dict]: an updated `threshold_kwargs` and `change_ledger`.\n        \"\"\"\n\n        if debug:\n            LOGGER.remove()\n            LOGGER.add(sys.stderr, level=\"DEBUG\")\n\n        _sig = signature(f)\n        LOGGER.debug(f\"Function {signature=}\")\n        _default: dict = {}\n\n        for k, v in _sig.parameters.items():\n            if v.default is not Parameter.empty:\n                _default[k] = v.default\n\n        LOGGER.debug(f\"{_default=}\")\n        for k in _default:\n            change_ledger[k] = {\"label\": cls.label, \"rank\": cls.rank}\n\n        threshold_kwargs.update(**_default)\n\n        return threshold_kwargs, change_ledger\n</code></pre>"},{"location":"autoapi/argmerge/func/#argmerge.func.FuncDefaultParser.__call__","title":"__call__","text":"<pre><code>__call__(threshold_kwargs, change_ledger, f, debug=False)\n</code></pre> <p>Lowest level parser - retrieve function defaults as fallback arguments.</p> <p>Parameters:</p> <ul> <li> <code>threshold_kwargs</code>               (<code>dict[str, Any]</code>)           \u2013            <p>kwargs passed around the @threshold decorator.</p> </li> <li> <code>change_ledger</code>               (<code>dict[str, dict[str, str | int]]</code>)           \u2013            <p>Tracks when kwargs are updated inside the @threshold decorator.</p> </li> <li> <code>f</code>               (<code>Callable</code>)           \u2013            <p>The function we wrap.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to turn on more logging. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[dict, dict]</code>           \u2013            <p>tuple[dict, dict]: an updated <code>threshold_kwargs</code> and <code>change_ledger</code>.</p> </li> </ul> Source code in <code>src/argmerge/func.py</code> <pre><code>def __call__(\n    cls,\n    threshold_kwargs: dict,\n    change_ledger: dict,\n    f: Callable,\n    debug: bool = False,\n) -&gt; tuple[dict, dict]:\n    \"\"\"Lowest level parser - retrieve function defaults as fallback arguments.\n\n    Args:\n        threshold_kwargs (dict[str, Any]): kwargs passed around the\n            @threshold decorator.\n        change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are\n            updated inside the @threshold decorator.\n        f (Callable): The function we wrap.\n        debug (bool, optional): Flag to turn on more logging. Defaults to False.\n\n\n    Returns:\n        tuple[dict, dict]: an updated `threshold_kwargs` and `change_ledger`.\n    \"\"\"\n\n    if debug:\n        LOGGER.remove()\n        LOGGER.add(sys.stderr, level=\"DEBUG\")\n\n    _sig = signature(f)\n    LOGGER.debug(f\"Function {signature=}\")\n    _default: dict = {}\n\n    for k, v in _sig.parameters.items():\n        if v.default is not Parameter.empty:\n            _default[k] = v.default\n\n    LOGGER.debug(f\"{_default=}\")\n    for k in _default:\n        change_ledger[k] = {\"label\": cls.label, \"rank\": cls.rank}\n\n    threshold_kwargs.update(**_default)\n\n    return threshold_kwargs, change_ledger\n</code></pre>"},{"location":"autoapi/argmerge/func/#argmerge.func.FuncUpdater","title":"FuncUpdater","text":"<p>               Bases: <code>SourceParser</code></p> <p>Builds the parser to extract default arguments from a function signature</p> <p>This is the highest-ranked parser.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The debugging label to indicate an argument was set at Runtime by the developer.</p> </li> <li> <code>rank</code>               (<code>int</code>)           \u2013            <p>The priority of the parser. Generally, we aim between [0,100] for human-readabilty.</p> </li> </ul> Source code in <code>src/argmerge/func.py</code> <pre><code>class FuncUpdater(SourceParser):\n    \"\"\"Builds the parser to extract default arguments from a function signature\n\n    This is the highest-ranked parser.\n\n    params:\n        label (str): The debugging label to indicate an argument was set at Runtime by\n            the developer.\n        rank (int): The priority of the parser. Generally, we aim between [0,100] for\n            human-readabilty.\n    \"\"\"\n\n    label: str = \"Developer-provided\"\n    rank: int = 100\n\n    def __call__(\n        cls,\n        threshold_kwargs: dict[str, Any],\n        change_ledger: dict[str, dict[str, str | int]],\n        func_kwargs: dict[str, Any],\n        debug: bool = False,\n    ) -&gt; tuple[dict, dict]:\n        \"\"\"Update the external values with the function's runtime arguments.\n\n        Args:\n            threshold_kwargs (dict[str, Any]): kwargs passed around the\n                @threshold decorator.\n            change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are\n                updated inside the @threshold decorator.\n            func_kwargs (dict[str, Any]): The Runtime kwargs of the function.\n            debug (bool, optional): Flag to turn on more logging. Defaults to False.\n\n        Returns:\n            Returns:\n            tuple[dict, dict]: an updated `threshold_kwargs` and `change_ledger`.\n        \"\"\"\n        if debug:\n            LOGGER.remove()\n            LOGGER.add(sys.stderr, level=\"DEBUG\")\n\n        LOGGER.debug(f\"{threshold_kwargs=}\")\n        LOGGER.debug(f\"{func_kwargs=}\")\n\n        threshold_kwargs.update(**func_kwargs)\n\n        for key in func_kwargs:\n            change_ledger[key] = {\"label\": cls.label, \"rank\": cls.rank}\n\n        return threshold_kwargs, change_ledger\n</code></pre>"},{"location":"autoapi/argmerge/func/#argmerge.func.FuncUpdater.__call__","title":"__call__","text":"<pre><code>__call__(threshold_kwargs, change_ledger, func_kwargs, debug=False)\n</code></pre> <p>Update the external values with the function's runtime arguments.</p> <p>Parameters:</p> <ul> <li> <code>threshold_kwargs</code>               (<code>dict[str, Any]</code>)           \u2013            <p>kwargs passed around the @threshold decorator.</p> </li> <li> <code>change_ledger</code>               (<code>dict[str, dict[str, str | int]]</code>)           \u2013            <p>Tracks when kwargs are updated inside the @threshold decorator.</p> </li> <li> <code>func_kwargs</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The Runtime kwargs of the function.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to turn on more logging. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Returns</code> (              <code>dict</code> )          \u2013            </li> <li> <code>dict</code>           \u2013            <p>tuple[dict, dict]: an updated <code>threshold_kwargs</code> and <code>change_ledger</code>.</p> </li> </ul> Source code in <code>src/argmerge/func.py</code> <pre><code>def __call__(\n    cls,\n    threshold_kwargs: dict[str, Any],\n    change_ledger: dict[str, dict[str, str | int]],\n    func_kwargs: dict[str, Any],\n    debug: bool = False,\n) -&gt; tuple[dict, dict]:\n    \"\"\"Update the external values with the function's runtime arguments.\n\n    Args:\n        threshold_kwargs (dict[str, Any]): kwargs passed around the\n            @threshold decorator.\n        change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are\n            updated inside the @threshold decorator.\n        func_kwargs (dict[str, Any]): The Runtime kwargs of the function.\n        debug (bool, optional): Flag to turn on more logging. Defaults to False.\n\n    Returns:\n        Returns:\n        tuple[dict, dict]: an updated `threshold_kwargs` and `change_ledger`.\n    \"\"\"\n    if debug:\n        LOGGER.remove()\n        LOGGER.add(sys.stderr, level=\"DEBUG\")\n\n    LOGGER.debug(f\"{threshold_kwargs=}\")\n    LOGGER.debug(f\"{func_kwargs=}\")\n\n    threshold_kwargs.update(**func_kwargs)\n\n    for key in func_kwargs:\n        change_ledger[key] = {\"label\": cls.label, \"rank\": cls.rank}\n\n    return threshold_kwargs, change_ledger\n</code></pre>"},{"location":"autoapi/argmerge/json/","title":"json","text":""},{"location":"autoapi/argmerge/json/#argmerge.json.JSONParser","title":"JSONParser","text":"<p>               Bases: <code>SourceParser</code></p> <p>The parser the extracts relevant arguments from a JSON file.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The debugging label to indicate an argument was set in a JSON config file.</p> </li> <li> <code>rank</code>               (<code>int</code>)           \u2013            <p>The priority of the parser. Generally, we aim between [0,100] for human-readabilty.</p> </li> </ul> Source code in <code>src/argmerge/json.py</code> <pre><code>class JSONParser(SourceParser):\n    \"\"\"The parser the extracts relevant arguments from a JSON file.\n\n    params:\n        label (str): The debugging label to indicate an argument was set in a JSON\n            config file.\n        rank (int): The priority of the parser. Generally, we aim between [0,100] for\n            human-readabilty.\n\n    \"\"\"\n\n    label: str = \"JSON\"\n    rank: int = 10\n\n    def __call__(\n        cls,\n        threshold_kwargs: dict[str, Any],\n        change_ledger: dict[str, dict[str, str | int]],\n        fpath_json: str | Path,\n        debug: bool = False,\n    ) -&gt; tuple[dict, dict]:\n        \"\"\"Parse a JSON configuration file for arguments\n\n         Args:\n            threshold_kwargs (dict[str, Any]): kwargs passed around the\n                @threshold decorator.\n            change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are\n                updated inside the @threshold decorator.\n            fpath_json (str | Path): The filepath to the JSON configuration file.\n            debug (bool, optional): Flag to turn on more logging. Defaults to False.\n\n        Raises:\n            ValueError: If filepath extension is not `json`.\n\n        Returns:\n            tuple[dict, dict]: an updated `threshold_kwargs` and `change_ledger`.\n        \"\"\"\n        _json_kwargs: dict\n\n        if debug:\n            LOGGER.remove()\n            LOGGER.add(sys.stderr, level=\"DEBUG\")\n\n        LOGGER.debug(f\"{threshold_kwargs=}\")\n        LOGGER.debug(f\"{fpath_json=}\")\n\n        _fpath_json = Path(fpath_json)\n        if _fpath_json == Path(\"\"):\n            LOGGER.debug(\"fpath_json not provided, skipping.\")\n\n        else:\n            if _fpath_json.suffix != \".json\":\n                raise ValueError(\n                    f\"The JSON suffix of '{_fpath_json.as_posix()}' is not correct.\"\n                    \" Please use '.json'.\"\n                )\n\n            cls.label = f\"JSON ({_fpath_json})\"\n\n            with open(fpath_json, \"rb\") as fy:\n                _json_kwargs = json.load(fy)\n\n            LOGGER.debug(f\"{_json_kwargs=}\")\n            threshold_kwargs.update(_json_kwargs)\n            LOGGER.debug(f\"Updated {threshold_kwargs=}\")\n\n            for key in _json_kwargs:\n                change_ledger[key] = {\"label\": cls.label, \"rank\": cls.rank}\n\n        return threshold_kwargs, change_ledger\n</code></pre>"},{"location":"autoapi/argmerge/json/#argmerge.json.JSONParser.__call__","title":"__call__","text":"<pre><code>__call__(threshold_kwargs, change_ledger, fpath_json, debug=False)\n</code></pre> <p>Parse a JSON configuration file for arguments</p> <p>Args:     threshold_kwargs (dict[str, Any]): kwargs passed around the         @threshold decorator.     change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are         updated inside the @threshold decorator.     fpath_json (str | Path): The filepath to the JSON configuration file.     debug (bool, optional): Flag to turn on more logging. Defaults to False.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If filepath extension is not <code>json</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[dict, dict]</code>           \u2013            <p>tuple[dict, dict]: an updated <code>threshold_kwargs</code> and <code>change_ledger</code>.</p> </li> </ul> Source code in <code>src/argmerge/json.py</code> <pre><code>def __call__(\n    cls,\n    threshold_kwargs: dict[str, Any],\n    change_ledger: dict[str, dict[str, str | int]],\n    fpath_json: str | Path,\n    debug: bool = False,\n) -&gt; tuple[dict, dict]:\n    \"\"\"Parse a JSON configuration file for arguments\n\n     Args:\n        threshold_kwargs (dict[str, Any]): kwargs passed around the\n            @threshold decorator.\n        change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are\n            updated inside the @threshold decorator.\n        fpath_json (str | Path): The filepath to the JSON configuration file.\n        debug (bool, optional): Flag to turn on more logging. Defaults to False.\n\n    Raises:\n        ValueError: If filepath extension is not `json`.\n\n    Returns:\n        tuple[dict, dict]: an updated `threshold_kwargs` and `change_ledger`.\n    \"\"\"\n    _json_kwargs: dict\n\n    if debug:\n        LOGGER.remove()\n        LOGGER.add(sys.stderr, level=\"DEBUG\")\n\n    LOGGER.debug(f\"{threshold_kwargs=}\")\n    LOGGER.debug(f\"{fpath_json=}\")\n\n    _fpath_json = Path(fpath_json)\n    if _fpath_json == Path(\"\"):\n        LOGGER.debug(\"fpath_json not provided, skipping.\")\n\n    else:\n        if _fpath_json.suffix != \".json\":\n            raise ValueError(\n                f\"The JSON suffix of '{_fpath_json.as_posix()}' is not correct.\"\n                \" Please use '.json'.\"\n            )\n\n        cls.label = f\"JSON ({_fpath_json})\"\n\n        with open(fpath_json, \"rb\") as fy:\n            _json_kwargs = json.load(fy)\n\n        LOGGER.debug(f\"{_json_kwargs=}\")\n        threshold_kwargs.update(_json_kwargs)\n        LOGGER.debug(f\"Updated {threshold_kwargs=}\")\n\n        for key in _json_kwargs:\n            change_ledger[key] = {\"label\": cls.label, \"rank\": cls.rank}\n\n    return threshold_kwargs, change_ledger\n</code></pre>"},{"location":"autoapi/argmerge/trace/","title":"trace","text":"<p>Module to write the source of each function keyword argument for the developer</p> <p>Example:</p> <pre><code>$ uv run main.py  # trace_level=DEBUG set in the program\n2025-10-14 16:15:33.466 | DEBUG    | argmerge.trace:_write_trace:50 -\nParameter Name  | Source\n=======================================\nthird   | Python Function default\nfourth  | Python Function default\nfifth   | Python Function default\nfirst   | developer-provided\nsecond  | developer-provided\n=======================================\n</code></pre>"},{"location":"autoapi/argmerge/trace/#argmerge.trace.trace_arg_lineage","title":"trace_arg_lineage","text":"<pre><code>trace_arg_lineage(f, change_ledger, level='')\n</code></pre> <p>Determine where each argument in the function came from.</p> <p>Only include arguments that exist in the function header. If a function accepts **kwargs and an irrelevant keyword is provided - discard it.</p> <p>Parameters:</p> <ul> <li> <code>f</code>               (<code>callable</code>)           \u2013            </li> <li> <code>change_ledger</code>               (<code>dict</code>)           \u2013            <p>The final dictionary detailing where every argument is set - defaults, files, environment variables, CLI arguments, etc.</p> </li> </ul> Source code in <code>src/argmerge/trace.py</code> <pre><code>def trace_arg_lineage(\n    f: Callable,\n    change_ledger: dict[str, dict[str, str | int]],\n    level: str = \"\",\n):\n    \"\"\"Determine where each argument in the function came from.\n\n    Only include arguments that exist in the function header. If a function accepts\n    **kwargs and an irrelevant keyword is provided - discard it.\n\n    args:\n        f (callable):\n        change_ledger (dict): The final dictionary detailing where every argument\n            is set - defaults, files, environment variables, CLI arguments, etc.\n    \"\"\"\n    sig = signature(f)\n    _changed = {k: v for k, v in change_ledger.items() if k in sig.parameters}\n\n    _log_trace(ledger=_changed, level=level)\n</code></pre>"},{"location":"autoapi/argmerge/utils/","title":"utils","text":"<p>Module for utility functions.</p>"},{"location":"autoapi/argmerge/yaml/","title":"yaml","text":""},{"location":"autoapi/argmerge/yaml/#argmerge.yaml.YAMLParser","title":"YAMLParser","text":"<p>               Bases: <code>SourceParser</code></p> <p>The parser the extracts relevant arguments from a YAML file.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>The debugging label to indicate an argument was set in a YAML config file.</p> </li> <li> <code>rank</code>               (<code>int</code>)           \u2013            <p>The priority of the parser. Generally, we aim between [0,100] for human-readabilty.</p> </li> </ul> Source code in <code>src/argmerge/yaml.py</code> <pre><code>class YAMLParser(SourceParser):\n    \"\"\"The parser the extracts relevant arguments from a YAML file.\n\n    params:\n        label (str): The debugging label to indicate an argument was set in a YAML\n            config file.\n        rank (int): The priority of the parser. Generally, we aim between [0,100] for\n            human-readabilty.\n\n    \"\"\"\n\n    label: str = \"YAML\"\n    rank: int = 20\n\n    def __call__(\n        cls,\n        threshold_kwargs: dict[str, str],\n        change_ledger: dict[str, dict[str, str | int]],\n        fpath_yaml: str | Path,\n        debug: bool = False,\n    ) -&gt; tuple[dict, dict]:\n        \"\"\"Parse a YAML configuration file for arguments\n\n         Args:\n            threshold_kwargs (dict[str, Any]): kwargs passed around the\n                @threshold decorator.\n            change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are\n                updated inside the @threshold decorator.\n            fpath_yaml (str | Path): The filepath to the YAML configuration file.\n            debug (bool, optional): Flag to turn on more logging. Defaults to False.\n\n        Raises:\n            ValueError: If filepath extension is not `yml` or `yaml`.\n\n        Returns:\n            tuple[dict, dict]: an updated `threshold_kwargs` and `change_ledger`.\n        \"\"\"\n        _yaml_kwargs: dict\n\n        if debug:\n            LOGGER.remove()\n            LOGGER.add(sys.stderr, level=\"DEBUG\")\n\n        LOGGER.debug(f\"{threshold_kwargs=}\")\n        LOGGER.debug(f\"{fpath_yaml=}\")\n\n        _fpath_yaml = Path(fpath_yaml)\n        if _fpath_yaml == Path(\"\"):\n            LOGGER.debug(\"fpath_yaml not provided, skipping.\")\n\n        else:\n            if _fpath_yaml.suffix not in (\".yml\", \".yaml\"):\n                raise ValueError(\n                    f\"The YAML suffix of '{_fpath_yaml.suffix}' is not correct.\"\n                    \" Please use '.yml' or '.yaml'.\"\n                )\n\n            cls.label = f\"YAML ({_fpath_yaml})\"\n\n            with open(fpath_yaml, \"rb\") as fy:\n                _yaml_kwargs = yaml.safe_load(fy)\n\n            LOGGER.debug(f\"{_yaml_kwargs=}\")\n            threshold_kwargs.update(_yaml_kwargs)\n            LOGGER.debug(f\"Updated {threshold_kwargs=}\")\n\n            for key in _yaml_kwargs:\n                change_ledger[key] = {\"label\": cls.label, \"rank\": cls.rank}\n\n        return threshold_kwargs, change_ledger\n</code></pre>"},{"location":"autoapi/argmerge/yaml/#argmerge.yaml.YAMLParser.__call__","title":"__call__","text":"<pre><code>__call__(threshold_kwargs, change_ledger, fpath_yaml, debug=False)\n</code></pre> <p>Parse a YAML configuration file for arguments</p> <p>Args:     threshold_kwargs (dict[str, Any]): kwargs passed around the         @threshold decorator.     change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are         updated inside the @threshold decorator.     fpath_yaml (str | Path): The filepath to the YAML configuration file.     debug (bool, optional): Flag to turn on more logging. Defaults to False.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If filepath extension is not <code>yml</code> or <code>yaml</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[dict, dict]</code>           \u2013            <p>tuple[dict, dict]: an updated <code>threshold_kwargs</code> and <code>change_ledger</code>.</p> </li> </ul> Source code in <code>src/argmerge/yaml.py</code> <pre><code>def __call__(\n    cls,\n    threshold_kwargs: dict[str, str],\n    change_ledger: dict[str, dict[str, str | int]],\n    fpath_yaml: str | Path,\n    debug: bool = False,\n) -&gt; tuple[dict, dict]:\n    \"\"\"Parse a YAML configuration file for arguments\n\n     Args:\n        threshold_kwargs (dict[str, Any]): kwargs passed around the\n            @threshold decorator.\n        change_ledger (dict[str, dict[str, str  |  int]]): Tracks when kwargs are\n            updated inside the @threshold decorator.\n        fpath_yaml (str | Path): The filepath to the YAML configuration file.\n        debug (bool, optional): Flag to turn on more logging. Defaults to False.\n\n    Raises:\n        ValueError: If filepath extension is not `yml` or `yaml`.\n\n    Returns:\n        tuple[dict, dict]: an updated `threshold_kwargs` and `change_ledger`.\n    \"\"\"\n    _yaml_kwargs: dict\n\n    if debug:\n        LOGGER.remove()\n        LOGGER.add(sys.stderr, level=\"DEBUG\")\n\n    LOGGER.debug(f\"{threshold_kwargs=}\")\n    LOGGER.debug(f\"{fpath_yaml=}\")\n\n    _fpath_yaml = Path(fpath_yaml)\n    if _fpath_yaml == Path(\"\"):\n        LOGGER.debug(\"fpath_yaml not provided, skipping.\")\n\n    else:\n        if _fpath_yaml.suffix not in (\".yml\", \".yaml\"):\n            raise ValueError(\n                f\"The YAML suffix of '{_fpath_yaml.suffix}' is not correct.\"\n                \" Please use '.yml' or '.yaml'.\"\n            )\n\n        cls.label = f\"YAML ({_fpath_yaml})\"\n\n        with open(fpath_yaml, \"rb\") as fy:\n            _yaml_kwargs = yaml.safe_load(fy)\n\n        LOGGER.debug(f\"{_yaml_kwargs=}\")\n        threshold_kwargs.update(_yaml_kwargs)\n        LOGGER.debug(f\"Updated {threshold_kwargs=}\")\n\n        for key in _yaml_kwargs:\n            change_ledger[key] = {\"label\": cls.label, \"rank\": cls.rank}\n\n    return threshold_kwargs, change_ledger\n</code></pre>"}]}